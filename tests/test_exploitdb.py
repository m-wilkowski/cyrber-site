"""Tests for ExploitDB integration — sync, enrichment, CSV parsing."""
import sys
import os
import tempfile
sys.path.insert(0, os.path.join(os.path.dirname(__file__), ".."))

from unittest.mock import patch, MagicMock

# Mock modules.database before importing intelligence_sync
_db_mock = MagicMock()
_original_db = sys.modules.get("modules.database")
if _original_db is None:
    sys.modules["modules.database"] = _db_mock

import modules.intelligence_sync as intel

if _original_db is not None:
    sys.modules["modules.database"] = _original_db


# ── CSV Parsing ─────────────────────────────────────────

class TestParseExploitdbCsv:

    def test_parse_csv_extracts_cves(self):
        """Parse CSV — rows with CVE get cve field populated, others get empty string."""
        csv_content = (
            "id,file,description,date_published,author,platform,type,port,codes\n"
            '12345,exploits/linux/remote/12345.py,"Test Exploit",2024-01-15,author1,linux,remote,,CVE-2024-1234;OSVDB-12345\n'
            '12346,exploits/windows/local/12346.rb,"Another Exploit",2024-02-20,author2,windows,local,445,CVE-2024-5678\n'
            '12347,exploits/multiple/dos/12347.txt,"No CVE Exploit",2024-03-01,author3,multiple,dos,,OSVDB-99999\n'
        )
        with tempfile.NamedTemporaryFile(mode="w", suffix=".csv", delete=False) as f:
            f.write(csv_content)
            f.flush()
            entries = intel._parse_exploitdb_csv(f.name)

        os.unlink(f.name)

        # All 3 rows are included
        assert len(entries) == 3
        assert entries[0]["exploit_id"] == 12345
        assert entries[0]["cve"] == "CVE-2024-1234"
        assert entries[0]["platform"] == "linux"
        assert entries[1]["exploit_id"] == 12346
        assert entries[1]["cve"] == "CVE-2024-5678"
        # Row without CVE has empty cve
        assert entries[2]["exploit_id"] == 12347
        assert entries[2]["cve"] == ""

    def test_parse_csv_first_cve_only(self):
        """When row has multiple CVEs, only first is used (one entry per row)."""
        csv_content = (
            "id,file,description,date_published,author,platform,type,port,codes\n"
            '99999,exploits/linux/remote/99999.py,"Multi CVE",2024-06-01,author1,linux,remote,,CVE-2024-1111;CVE-2024-2222;OSVDB-1\n'
        )
        with tempfile.NamedTemporaryFile(mode="w", suffix=".csv", delete=False) as f:
            f.write(csv_content)
            f.flush()
            entries = intel._parse_exploitdb_csv(f.name)

        os.unlink(f.name)

        assert len(entries) == 1
        assert entries[0]["cve"] == "CVE-2024-1111"
        assert entries[0]["exploit_id"] == 99999

    def test_parse_csv_empty_file(self):
        """Empty CSV (header only) returns empty list."""
        csv_content = "id,file,description,date_published,author,platform,type,port,codes\n"
        with tempfile.NamedTemporaryFile(mode="w", suffix=".csv", delete=False) as f:
            f.write(csv_content)
            f.flush()
            entries = intel._parse_exploitdb_csv(f.name)

        os.unlink(f.name)
        assert entries == []


# ── sync_exploitdb ──────────────────────────────────────

class TestSyncExploitdb:

    def test_sync_exploitdb_git_pull(self):
        """When .git dir exists, should git pull then parse CSV."""
        def fake_isdir(path):
            return ".git" in str(path)

        with patch("os.path.isdir", side_effect=fake_isdir), \
             patch("os.path.isfile", return_value=True), \
             patch("subprocess.run") as mock_run, \
             patch.object(intel, "_parse_exploitdb_csv", return_value=[
                 {"exploit_id": 1, "cve": "CVE-2024-0001", "description": "Test"}
             ]), \
             patch.object(intel, "upsert_exploitdb_entries", return_value=1) as mock_upsert, \
             patch.object(intel, "save_intel_sync_log") as mock_log:

            result = intel.sync_exploitdb()

            assert result == 1
            mock_upsert.assert_called_once()
            mock_log.assert_called_once()
            assert mock_log.call_args[0][1] == "success"
            pull_calls = [c for c in mock_run.call_args_list if "pull" in str(c)]
            assert len(pull_calls) >= 1

    def test_sync_exploitdb_git_clone(self):
        """When .git dir doesn't exist, should git clone."""
        with patch("os.path.isdir", return_value=False), \
             patch("os.path.isfile", return_value=True), \
             patch("os.makedirs"), \
             patch("subprocess.run") as mock_run, \
             patch.object(intel, "_parse_exploitdb_csv", return_value=[]), \
             patch.object(intel, "upsert_exploitdb_entries", return_value=0), \
             patch.object(intel, "save_intel_sync_log"):

            result = intel.sync_exploitdb()

            assert result == 0
            clone_calls = [c for c in mock_run.call_args_list if "clone" in str(c)]
            assert len(clone_calls) >= 1

    def test_sync_exploitdb_error_logged(self):
        """On git error, should log error and re-raise."""
        with patch("os.path.isdir", return_value=True), \
             patch("subprocess.run", side_effect=Exception("git failed")), \
             patch.object(intel, "save_intel_sync_log") as mock_log:

            try:
                intel.sync_exploitdb()
                assert False, "Should have raised"
            except Exception as e:
                assert "git failed" in str(e)

            mock_log.assert_called_once()
            assert mock_log.call_args[0][1] == "error"


# ── enrich_finding + ExploitDB ──────────────────────────

class TestEnrichFindingExploitdb:

    def test_enrich_adds_exploitdb_data(self):
        """enrich_finding should add exploitdb_count and exploitdb_ids."""
        mock_exploits = [
            {"exploit_id": 12345, "description": "Linux RCE", "url": "https://exploit-db.com/exploits/12345"},
            {"exploit_id": 12346, "description": "PoC", "url": "https://exploit-db.com/exploits/12346"},
        ]

        with patch.object(intel, "get_intel_enrichment", return_value={
                 "cvss_score": 9.8, "epss_score": 0.5, "in_kev": True, "cwe_id": "CWE-79"
             }), \
             patch.object(intel, "calculate_priority", return_value=(95, ["kev", "cvss"])), \
             patch.object(intel, "get_techniques_for_cwe", return_value=[]), \
             patch.object(intel, "get_euvd_by_cve", return_value=None), \
             patch("modules.intelligence_sync.get_misp_by_cve", create=True, return_value=None), \
             patch.object(intel, "get_urlhaus_cache", return_value=None), \
             patch.object(intel, "get_exploitdb_by_cve", return_value=mock_exploits):

            result = intel.enrich_finding("CVE-2024-1234")

            assert result["exploitdb_count"] == 2
            assert len(result["exploitdb_ids"]) == 2

    def test_enrich_no_exploitdb(self):
        """enrich_finding with no ExploitDB matches should have count=0."""
        with patch.object(intel, "get_intel_enrichment", return_value={
                 "cvss_score": 5.0, "epss_score": 0.1, "in_kev": False
             }), \
             patch.object(intel, "calculate_priority", return_value=(40, [])), \
             patch.object(intel, "get_techniques_for_cwe", return_value=[]), \
             patch.object(intel, "get_euvd_by_cve", return_value=None), \
             patch("modules.intelligence_sync.get_misp_by_cve", create=True, return_value=None), \
             patch.object(intel, "get_urlhaus_cache", return_value=None), \
             patch.object(intel, "get_exploitdb_by_cve", return_value=[]):

            result = intel.enrich_finding("CVE-2024-9999")

            assert result["exploitdb_count"] == 0
            assert result["exploitdb_ids"] == []
