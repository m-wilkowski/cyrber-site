import os
import re
import csv
import io
import time
import requests

CACHE_PATH = os.getenv("EXPLOITDB_CACHE_PATH", "/app/data/exploitdb.csv")
EXPLOITDB_CSV_URL = "https://gitlab.com/exploit-database/exploitdb/-/raw/main/files_exploits.csv"
CACHE_MAX_AGE = 86400  # 24 hours


def _ensure_cache():
    """Download ExploitDB CSV if missing or older than 24h. Returns True if cache is usable."""
    cache_dir = os.path.dirname(CACHE_PATH)
    if cache_dir:
        os.makedirs(cache_dir, exist_ok=True)

    need_download = True
    if os.path.exists(CACHE_PATH):
        age = time.time() - os.path.getmtime(CACHE_PATH)
        if age < CACHE_MAX_AGE:
            need_download = False

    if need_download:
        try:
            print("[exploitdb] Downloading ExploitDB CSV...")
            r = requests.get(EXPLOITDB_CSV_URL, timeout=30)
            r.raise_for_status()
            with open(CACHE_PATH, "w", encoding="utf-8") as f:
                f.write(r.text)
            print(f"[exploitdb] Cached to {CACHE_PATH}")
        except Exception as e:
            print(f"[exploitdb] Download failed: {e}")
            if os.path.exists(CACHE_PATH):
                print("[exploitdb] Using stale cache")
            else:
                return False
    return os.path.exists(CACHE_PATH)


def _load_cve_index():
    """Load CSV and build a CVE -> list of exploits index."""
    cve_index = {}
    try:
        with open(CACHE_PATH, "r", encoding="utf-8", errors="replace") as f:
            reader = csv.DictReader(f)
            for row in reader:
                codes = row.get("codes", "")
                if not codes:
                    continue
                # codes field contains semicolon-separated list: "CVE-2021-1234;OSVDB-12345"
                cves_in_row = re.findall(r"CVE-\d{4}-\d+", codes, re.IGNORECASE)
                for cve in cves_in_row:
                    cve_upper = cve.upper()
                    if cve_upper not in cve_index:
                        cve_index[cve_upper] = []
                    edb_id = row.get("id", "")
                    exploit_type = (row.get("type", "") or "").strip()
                    platform = (row.get("platform", "") or "").strip()
                    verified = str(row.get("verified", "0")).strip() == "1"

                    # Determine severity
                    if exploit_type == "remote" and verified:
                        severity = "critical"
                    elif exploit_type == "remote":
                        severity = "high"
                    elif exploit_type == "webapps":
                        severity = "medium"
                    else:
                        severity = "low"

                    cve_index[cve_upper].append({
                        "edb_id": edb_id,
                        "title": (row.get("description", "") or "").strip(),
                        "type": exploit_type,
                        "platform": platform,
                        "date": (row.get("date_published", "") or "").strip(),
                        "author": (row.get("author", "") or "").strip(),
                        "verified": verified,
                        "url": f"https://www.exploit-db.com/exploits/{edb_id}",
                        "severity": severity,
                    })
    except Exception as e:
        print(f"[exploitdb] Failed to parse CSV: {e}")
    return cve_index


def _to_str(val) -> str:
    """Convert a value to string for CVE extraction. Handles dict, list, None."""
    if val is None:
        return ""
    if isinstance(val, str):
        return val
    if isinstance(val, dict):
        return " ".join(_to_str(v) for v in val.values() if v)
    if isinstance(val, (list, tuple)):
        return " ".join(_to_str(v) for v in val if v)
    return str(val)


def extract_cves(scan_results: dict) -> list:
    """Extract unique CVE IDs from nuclei, nmap, and nikto scan results."""
    cves = set()

    # Nuclei findings
    nuclei = scan_results.get("nuclei", {})
    nuclei_findings = nuclei.get("findings", []) if isinstance(nuclei, dict) else []
    for finding in nuclei_findings:
        text = " ".join(
            _to_str(finding.get(k, ""))
            for k in ("name", "template-id", "info", "reference", "description")
        )
        for cve in re.findall(r"CVE-\d{4}-\d+", text, re.IGNORECASE):
            cves.add(cve.upper())

    # Nmap raw output or port info
    ports = scan_results.get("ports", [])
    for p in ports:
        version = p.get("version", "") or ""
        service = p.get("service", "") or ""
        for cve in re.findall(r"CVE-\d{4}-\d+", version + " " + service, re.IGNORECASE):
            cves.add(cve.upper())

    # Nikto findings
    nikto = scan_results.get("nikto", {})
    nikto_findings = nikto.get("findings", []) if isinstance(nikto, dict) else []
    for finding in nikto_findings:
        desc = finding.get("description", "") or ""
        url = finding.get("url", "") or ""
        for cve in re.findall(r"CVE-\d{4}-\d+", desc + " " + url, re.IGNORECASE):
            cves.add(cve.upper())

    return sorted(cves)


def exploitdb_scan(scan_results: dict) -> dict:
    """Search ExploitDB for exploits matching CVEs found in scan results.

    Args:
        scan_results: Combined scan results dict with nuclei, nmap, nikto data.

    Returns:
        Dict with exploits list, counts by severity, and matched CVEs.
    """
    cves = extract_cves(scan_results)
    if not cves:
        return {"exploits": [], "matched_cves": [], "total": 0}

    if not _ensure_cache():
        return {
            "exploits": [],
            "matched_cves": cves,
            "total": 0,
            "error": "ExploitDB cache unavailable",
        }

    cve_index = _load_cve_index()

    exploits = []
    matched_cves = []
    seen_edb_ids = set()

    for cve in cves:
        if cve in cve_index:
            matched_cves.append(cve)
            for exploit in cve_index[cve]:
                if exploit["edb_id"] not in seen_edb_ids:
                    seen_edb_ids.add(exploit["edb_id"])
                    exploit_entry = dict(exploit)
                    exploit_entry["cve"] = cve
                    exploits.append(exploit_entry)

    # Sort: critical first, then high, medium, low
    severity_order = {"critical": 0, "high": 1, "medium": 2, "low": 3}
    exploits.sort(key=lambda e: (severity_order.get(e["severity"], 4), e.get("date", "") or ""))

    critical_count = sum(1 for e in exploits if e["severity"] == "critical")
    high_count = sum(1 for e in exploits if e["severity"] == "high")
    medium_count = sum(1 for e in exploits if e["severity"] == "medium")
    low_count = sum(1 for e in exploits if e["severity"] == "low")

    return {
        "exploits": exploits,
        "matched_cves": matched_cves,
        "total": len(exploits),
        "critical_count": critical_count,
        "high_count": high_count,
        "medium_count": medium_count,
        "low_count": low_count,
    }
