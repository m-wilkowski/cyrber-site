import json
from modules.llm_provider import get_provider


def generate_exploit_chains(scan_result: dict) -> dict:
    target = scan_result.get("target", "unknown")
    analysis = scan_result.get("analysis", {})
    nuclei = scan_result.get("nuclei", {})
    gobuster = scan_result.get("gobuster", {})
    whatweb = scan_result.get("whatweb", {})
    sqlmap = scan_result.get("sqlmap", {})
    ports = scan_result.get("ports", [])

    findings = nuclei.get("findings", [])
    findings_summary = [
        {
            "name": f["info"]["name"],
            "severity": f["info"]["severity"],
            "description": f["info"].get("description", ""),
            "cve": f["info"].get("classification", {}).get("cve-id"),
            "cvss": f["info"].get("classification", {}).get("cvss-score"),
        }
        for f in findings
    ]

    prompt = f"""Jesteś ekspertem ds. cyberbezpieczeństwa z certyfikatem OSCP. Przeanalizuj wyniki skanowania i wygeneruj realistyczne łańcuchy exploitów.

Target: {target}
Otwarte porty: {json.dumps(ports[:15], ensure_ascii=False)}
Technologie: {json.dumps(whatweb.get('technologies', [])[:10], ensure_ascii=False)}
Podatności Nuclei: {json.dumps(findings_summary[:20], ensure_ascii=False)}
Ścieżki Gobuster: {json.dumps([f['path'] for f in gobuster.get('findings', [])[:15]])}
SQL Injection: {sqlmap.get('vulnerable', False)}
Ogólna ocena: {analysis.get('risk_level', 'NIEZNANE')}

Wygeneruj maksymalnie 3 realistyczne łańcuchy exploitów. Każdy łańcuch musi:
1. Łączyć minimum 2 podatności w sekwencję kroków
2. Zawierać szacowany czas wykonania
3. Zawierać wpływ biznesowy w PLN/EUR
4. Być realistyczny (nie teoretyczny)
5. Każdy krok musi mieć pole "confidence" (float 0.0-1.0):
   1.0 = potwierdzone (2+ skanery, znane CVE)
   0.7-0.9 = prawdopodobne (1 skaner, logiczny wniosek)
   0.4-0.6 = spekulatywne (brak dowodów, możliwe)
   0.1-0.3 = teoretyczne (wymaga dodatkowego recon)

Odpowiedz TYLKO w JSON:
{{
  "chains": [
    {{
      "id": 1,
      "name": "Nazwa łańcucha (krótka, opisowa)",
      "probability": 85,
      "total_time": "2-4 godziny",
      "impact": "KRYTYCZNY|WYSOKI|ŚREDNI",
      "business_impact": "Opis wpływu biznesowego z kwotą",
      "steps": [
        {{
          "step": 1,
          "action": "Co robi atakujący",
          "vulnerability": "Nazwa podatności",
          "time": "30 minut",
          "result": "Co osiąga",
          "confidence": 0.85
        }}
      ],
      "final_access": "Co atakujący przejmuje",
      "remediation_priority": "NATYCHMIAST|7 DNI|30 DNI"
    }}
  ],
  "attack_surface_score": 7,
  "summary": "Krótkie podsumowanie powierzchni ataku"
}}"""

    provider = get_provider(task="exploit_chains")

    try:
        response_text = provider.chat(prompt, max_tokens=2048)
        clean = response_text.strip()
        if clean.startswith("```"):
            clean = clean.split("```")[1]
            if clean.startswith("json"):
                clean = clean[4:]
        try:
            result = json.loads(clean.strip())
        except json.JSONDecodeError:
            start = response_text.find("{")
            end = response_text.rfind("}") + 1
            result = json.loads(response_text[start:end])
        # Validate confidence per step and compute confidence_avg per chain
        for chain in result.get("chains", []):
            if not isinstance(chain, dict):
                continue
            steps = chain.get("steps", [])
            confs = []
            for step in steps:
                if not isinstance(step, dict):
                    continue
                conf = step.get("confidence")
                if conf is None:
                    step["confidence"] = 0.5
                else:
                    try:
                        step["confidence"] = max(0.0, min(1.0, float(conf)))
                    except (TypeError, ValueError):
                        step["confidence"] = 0.5
                confs.append(step["confidence"])
            chain["confidence_avg"] = round(sum(confs) / len(confs), 2) if confs else 0.5

        return {"target": target, "exploit_chains": result, "provider": provider.name}

    except Exception as e:
        print(f"[exploit_chains] {provider.name} failed: {e}")
        return {
            "target": target,
            "exploit_chains": {"chains": [], "summary": f"Analysis failed: {e}"},
            "provider": "none",
            "error": str(e)
        }
